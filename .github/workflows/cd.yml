# CD Workflow - Release & Documentation Sync
#
# ARCHITECTURE:
# 1. Build once in the build job, upload artifact
# 2. Deploy job downloads artifact and deploys to GitHub Pages
# 3. Docs job downloads and syncs to org portal
#
# DOCUMENTATION TOOLS (auto-detected):
# - Python: Sphinx + autodoc2 ‚Üí Markdown
# - TypeScript/Node.js: TypeDoc ‚Üí Markdown  
# - Rust: rustdoc ‚Üí HTML (converted to MD)
# - Go: pkgsite/godoc ‚Üí Markdown
#
# Managed by: [ORG]/control-center

name: CD

on:
  push:
    branches: [main]
  release:
    types: [published]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write
  packages: write

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: false

env:
  ORG_NAME: ${{ github.repository_owner }}
  REPO_NAME: ${{ github.event.repository.name }}
  NODE_VERSION: 25
  PNPM_VERSION: 10

jobs:
  # ==========================================================================
  # Detect & Setup
  # ==========================================================================
  detect:
    name: Detect Stack
    runs-on: ubuntu-latest
    # Skip for portal and control-center repos
    if: |
      !endsWith(github.repository, '.github.io') && 
      !endsWith(github.repository, 'control-center')
    outputs:
      is_python: ${{ steps.detect.outputs.is_python }}
      is_node: ${{ steps.detect.outputs.is_node }}
      is_rust: ${{ steps.detect.outputs.is_rust }}
      is_go: ${{ steps.detect.outputs.is_go }}
      has_release: ${{ steps.detect.outputs.has_release }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          sparse-checkout: |
            pyproject.toml
            package.json
            Cargo.toml
            go.mod
          sparse-checkout-cone-mode: false

      - id: detect
        run: |
          echo "is_python=$([[ -f pyproject.toml ]] && echo true || echo false)" >> $GITHUB_OUTPUT
          echo "is_node=$([[ -f package.json ]] && echo true || echo false)" >> $GITHUB_OUTPUT
          echo "is_rust=$([[ -f Cargo.toml ]] && echo true || echo false)" >> $GITHUB_OUTPUT
          echo "is_go=$([[ -f go.mod ]] && echo true || echo false)" >> $GITHUB_OUTPUT
          echo "has_release=$([[ '${{ github.event_name }}' == 'release' ]] && echo true || echo false)" >> $GITHUB_OUTPUT

  # ==========================================================================
  # Node.js/TypeScript: Build Once, Upload Artifacts
  # ==========================================================================
  build:
    name: Build
    needs: detect
    if: needs.detect.outputs.is_node == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0

      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          registry-url: 'https://registry.npmjs.org'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      # Build client for GitHub Pages (with base path for repo subdirectory)
      - name: Build client
        run: pnpm run build:client
        env:
          VITE_BASE_PATH: /${{ env.REPO_NAME }}/

      # Copy generated assets to dist for Asset Review gallery
      - name: Copy generated assets
        run: |
          # Copy attached_assets to dist/public for asset review
          mkdir -p dist/public/attached_assets
          cp -r attached_assets/generated_images dist/public/attached_assets/ 2>/dev/null || true
          cp -r attached_assets/generated_videos dist/public/attached_assets/ 2>/dev/null || true
          
          # Ensure client assets are accessible
          mkdir -p dist/public/client/src/assets
          cp -r client/src/assets/* dist/public/client/src/assets/ 2>/dev/null || true
          
          echo "üì¶ Assets copied for review gallery"
          ls -la dist/public/attached_assets/ 2>/dev/null || echo "No attached_assets"

      # Build TypeDoc documentation
      - name: Build Documentation
        run: |
          mkdir -p docs-output
          
          # Install typedoc with markdown plugin
          pnpm add -D typedoc typedoc-plugin-markdown 2>/dev/null || true
          
          # Try package.json docs script first
          if pnpm run docs 2>/dev/null; then
            cp -r docs/* docs-output/ 2>/dev/null || true
          else
            # Generate with typedoc directly
            npx typedoc --plugin typedoc-plugin-markdown --out docs-output src/ 2>/dev/null || \
            echo "# API Documentation\n\nSee source code for details." > docs-output/index.md
          fi

      # Upload build artifact for deploy job
      - name: Upload build artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: build-dist
          path: dist/public/
          retention-days: 7

      # Upload docs artifact for sync-docs job
      - name: Upload docs artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: docs-nodejs
          path: docs-output/
          retention-days: 7

  # ==========================================================================
  # Deploy to GitHub Pages (downloads build artifact)
  # ==========================================================================
  deploy:
    name: Deploy to GitHub Pages
    needs: build
    runs-on: ubuntu-latest
    steps:
      # Download build artifact from build job
      - name: Download build artifact
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          name: build-dist
          path: dist/public

      # Release to crates.io (only on release event)
      - name: Publish to crates.io
        if: needs.detect.outputs.has_release == 'true'
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CRATES_IO_TOKEN }}
        run: cargo publish || echo "Already published or no token"

      - name: Upload to GitHub Pages
        uses: actions/upload-pages-artifact@56afc609e74202658d3ffba0e8f6dda462b719fa # v3.0.1
        with:
          name: docs-rust
          path: docs-output/

  # ==========================================================================
  # Go: Build, Test, Release, Docs
  # ==========================================================================
  golang:
    name: Go CD
    needs: detect
    if: needs.detect.outputs.is_go == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version: '1.22'

      - name: Build
        run: go build -v ./...

      # Build Go documentation
      - name: Build Documentation
        run: |
          mkdir -p docs-output
          
          # Generate markdown from go doc
          echo "# API Documentation" > docs-output/index.md
          echo "" >> docs-output/index.md
          go doc -all ./... >> docs-output/index.md 2>/dev/null || true
          
          # Try pkgsite for HTML (optional)
          go install golang.org/x/pkgsite/cmd/pkgsite@latest 2>/dev/null || true

      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: docs-go
          path: docs-output/

  # ==========================================================================
  # Build Android APKs (downloads build artifact, creates APKs for all archs)
  # ==========================================================================
  build-android:
    name: Build Android APKs
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - abi: arm64-v8a
            arch_name: arm64
          - abi: armeabi-v7a
            arch_name: arm32
          - abi: x86_64
            arch_name: x86_64
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup pnpm
        uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0

      - name: Setup Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Setup Java 17
        uses: actions/setup-java@5d7b2146334bacf88728daaa70414a99f5164e0f # v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Android SDK
        uses: android-actions/setup-android@9fc6c4e9069bf8d3d10b2204b1fb8f6ef7065407 # v3

      - name: Setup Gradle
        uses: gradle/actions@bfd569614358980afc8f89c2730eee75bb97efdf # v4
        with:
          gradle-version: '8.7'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      # Download pre-built web assets
      - name: Download build artifact
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          name: build-dist
          path: dist/public

      # Initialize Capacitor Android platform if not exists
      - name: Add Capacitor Android platform
        run: |
          if [ ! -d "android" ]; then
            npx cap add android
          fi
          npx cap sync android

      # Generate debug keystore with random password (throwaway for debug builds)
      - name: Generate debug keystore
        id: keystore
        run: |
          mkdir -p android/app
          # Generate random password for this build (ephemeral, no need to store)
          KEYSTORE_PASS=$(openssl rand -base64 24 | tr -dc 'a-zA-Z0-9' | head -c 32)
          echo "::add-mask::$KEYSTORE_PASS"
          echo "keystore_pass=$KEYSTORE_PASS" >> $GITHUB_OUTPUT
          
          keytool -genkey -v -keystore android/app/debug.keystore \
            -storepass "$KEYSTORE_PASS" -alias androiddebugkey -keypass "$KEYSTORE_PASS" \
            -keyalg RSA -keysize 2048 -validity 1 \
            -dname "CN=Debug, OU=Debug, O=Debug, L=Debug, ST=Debug, C=US"

      # Configure build.gradle for specific ABI
      - name: Configure ABI filter
        run: |
          # Add ABI filter to build.gradle
          sed -i '/android {/a\    splits {\n        abi {\n            enable true\n            reset()\n            include "${{ matrix.abi }}"\n            universalApk false\n        }\n    }' android/app/build.gradle || true

      # Build APK with ephemeral keystore
      - name: Build APK
        working-directory: android
        run: |
          set -euo pipefail
          echo "üî® Building APK for ${{ matrix.abi }}..."
          
          if ! ./gradlew assembleDebug \
            -Pandroid.injected.signing.store.file=${{ github.workspace }}/android/app/debug.keystore \
            -Pandroid.injected.signing.store.password=${{ steps.keystore.outputs.keystore_pass }} \
            -Pandroid.injected.signing.key.alias=androiddebugkey \
            -Pandroid.injected.signing.key.password=${{ steps.keystore.outputs.keystore_pass }}; then
            echo "‚ùå Gradle build failed for ${{ matrix.abi }}"
            exit 1
          fi
          
          echo "‚úÖ Gradle build completed"

      # Find and rename APK with validation
      - name: Prepare APK artifact
        id: apk
        run: |
          set -euo pipefail
          
          # Wait briefly for filesystem sync
          sleep 2
          
          APK_PATH=$(find android/app/build/outputs/apk -name "*.apk" -type f 2>/dev/null | head -1)
          
          if [ -z "$APK_PATH" ]; then
            echo "‚ùå APK not found in android/app/build/outputs/apk"
            echo "üìÅ Directory contents:"
            find android/app/build -name "*.apk" -type f 2>/dev/null || echo "No APKs found anywhere"
            exit 1
          fi
          
          # Validate APK size (should be > 1MB for a real APK)
          APK_SIZE=$(stat -f%z "$APK_PATH" 2>/dev/null || stat -c%s "$APK_PATH")
          if [ "$APK_SIZE" -lt 1000000 ]; then
            echo "‚ö†Ô∏è APK seems too small ($APK_SIZE bytes), may be corrupted"
          fi
          
          NEW_NAME="otterblade-odyssey-${{ matrix.arch_name }}.apk"
          cp "$APK_PATH" "$NEW_NAME"
          echo "apk_path=$NEW_NAME" >> $GITHUB_OUTPUT
          echo "‚úÖ APK prepared: $NEW_NAME ($APK_SIZE bytes)"

      # Upload APK artifact
      - name: Upload APK artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: apk-${{ matrix.arch_name }}
          path: ${{ steps.apk.outputs.apk_path }}
          retention-days: 7

  # ==========================================================================
  # Create GitHub Release with APKs (only on release event or manual trigger)
  # ==========================================================================
  release-android:
    name: Release Android APKs
    needs: [build-android, detect]
    if: |
      always() &&
      !cancelled() &&
      needs.build-android.result == 'success' &&
      (github.event_name == 'release' || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    steps:
      # Download all APK artifacts
      - name: Download ARM64 APK
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          name: apk-arm64
          path: apks/

      - name: Download ARM32 APK
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          name: apk-arm32
          path: apks/

      - name: Download x86_64 APK
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          name: apk-x86_64
          path: apks/

      - name: List APKs
        run: ls -la apks/

      # Create or update GitHub Release
      - name: Create GitHub Release
        uses: softprops/action-gh-release@5122b4edc95f85501a71628a57dc180a03ec7588 # v2
        with:
          tag_name: ${{ github.event_name == 'release' && github.event.release.tag_name || format('v{0}-dev', github.run_number) }}
          name: ${{ github.event_name == 'release' && github.event.release.name || format('Development Build #{0}', github.run_number) }}
          body: |
            ## Otterblade Odyssey - Android APKs

            ### Download for your device:
            - **ARM64 (arm64-v8a)**: Most modern Android devices (recommended)
            - **ARM32 (armeabi-v7a)**: Older 32-bit Android devices
            - **x86_64**: Android emulators and Intel-based devices

            ### Installation
            1. Download the APK matching your device architecture
            2. Enable "Install from unknown sources" in Android settings
            3. Open the APK file to install

            > ‚ö†Ô∏è **Note**: These are debug builds, signed with a debug key.
            > Not intended for Google Play Store distribution.

            ---
            Built from commit: ${{ github.sha }}
            Workflow run: [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          draft: ${{ github.event_name == 'workflow_dispatch' }}
          prerelease: ${{ github.event_name == 'workflow_dispatch' }}
          files: |
            apks/*.apk
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ==========================================================================
  # Sync Documentation to Org Portal (downloads docs artifact)
  # ==========================================================================
  sync-docs:
    name: Sync to Portal
    needs: [detect, build]
    if: |
      always() && 
      !cancelled() &&
      needs.build.result == 'success'
    runs-on: ubuntu-latest
    steps:
      # Download docs artifact from build job
      - name: Download docs artifact
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          name: docs-nodejs
          path: all-docs

      - name: Sync to org documentation portal
        env:
          DOCS_TOKEN: ${{ secrets.CI_GITHUB_TOKEN }}
          ORG: ${{ env.ORG_NAME }}
          REPO: ${{ env.REPO_NAME }}
        run: |
          PORTAL="${ORG}.github.io"
          
          # Derive package ID (strip common prefixes)
          PACKAGE_ID=$(echo "$REPO" | sed 's/^strata-//' | sed 's/^agentic-//' | sed 's/^extended-//')
          
          echo "üìö Syncing docs for $REPO ‚Üí $PORTAL/src/content/docs/$PACKAGE_ID/"
          
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"
          
          # Clone portal
          if ! git clone "https://x-access-token:${DOCS_TOKEN}@github.com/${ORG}/${PORTAL}.git" portal 2>/dev/null; then
            echo "‚ö†Ô∏è Portal repo ${ORG}/${PORTAL} not found - skipping sync"
            exit 0
          fi
          
          # Target directory
          TARGET="portal/src/content/docs/packages/${PACKAGE_ID}"
          mkdir -p "$TARGET"
          
          # Copy docs
          if [ -d "all-docs" ] && [ "$(ls -A all-docs 2>/dev/null)" ]; then
            cp -r all-docs/* "$TARGET/"
            
            # Ensure frontmatter for Starlight
            for f in "$TARGET"/*.md; do
              if [ -f "$f" ] && ! grep -q "^---" "$f"; then
                TITLE=$(basename "$f" .md | sed 's/-/ /g' | sed 's/\b\(.\)/\u\1/g')
                sed -i "1i---\ntitle: $TITLE\n---\n" "$f"
              fi
            done
            
            # Create index if missing
            if [ ! -f "$TARGET/index.md" ] && [ ! -f "$TARGET/index.mdx" ]; then
              echo "---" > "$TARGET/index.mdx"
              echo "title: $REPO" >> "$TARGET/index.mdx"
              echo "description: API documentation for $REPO" >> "$TARGET/index.mdx"
              echo "---" >> "$TARGET/index.mdx"
              echo "" >> "$TARGET/index.mdx"
              echo "# $REPO" >> "$TARGET/index.mdx"
              echo "" >> "$TARGET/index.mdx"
              echo "Auto-generated API documentation." >> "$TARGET/index.mdx"
              echo "" >> "$TARGET/index.mdx"
              echo "See the [source repository](https://github.com/${ORG}/${REPO}) for more details." >> "$TARGET/index.mdx"
            fi
          fi
          
          cd portal
          if [ -n "$(git status --porcelain)" ]; then
            git add .
            git commit -m "docs($PACKAGE_ID): sync from $REPO
            
            Auto-synced from: https://github.com/${ORG}/${REPO}
            Triggered by: ${{ github.event_name }}"
            
            git push origin main
            echo "‚úÖ Documentation synced successfully"
          else
            echo "‚ÑπÔ∏è No documentation changes"
          fi
